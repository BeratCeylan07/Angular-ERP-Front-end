import { Directive, EventEmitter, HostListener, Input, Output } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { SwalComponent } from './swal.component';
import * as i0 from "@angular/core";
/**
 * [swal] directive. It takes a value that defines the SweetAlert and can be of three types:
 *
 * 1) A simple array of two or three strings defining [title, text, icon] - the icon being optional, ex:
 *
 *    <button [swal]="['Title', 'Text']">Click me</button>
 *
 * 2) A native SweetAlert2 options object, ex:
 *
 *    <button [swal]="{ title: 'Title', text: 'Text' }">Click me</button>
 *
 * 3) A reference to an existing SwalComponent instance for more advanced uses, ex:
 *
 *    <button [swal]="mySwal">Click me</button>
 *    <swal #mySwal title="Title" text="Text"></swal>
 */
export class SwalDirective {
    viewContainerRef;
    resolver;
    /**
     * SweetAlert2 options or a SwalComponent instance.
     * See the class doc block for more informations.
     */
    set swal(options) {
        if (options instanceof SwalComponent) {
            this.swalInstance = options;
        }
        else if (isArrayOptions(options)) {
            this.swalOptions = {};
            [this.swalOptions.title, this.swalOptions.text, this.swalOptions.icon] = options;
        }
        else {
            this.swalOptions = options;
        }
        function isArrayOptions(value) {
            return Array.isArray(options);
        }
    }
    /**
     * Emits when the user clicks "Confirm".
     * The event value ($event) can be either:
     *  - by default, just `true`,
     *  - when using {@link input}, the input value,
     *  - when using {@link preConfirm}, the return value of this function.
     *
     * Example:
     *     <swal (confirm)="handleConfirm($event)"></swal>
     *
     *     public handleConfirm(email: string): void {
     *         // ... save user email
     *     }
     */
    confirm = new EventEmitter();
    /**
     * Emits when the user clicks "Deny".
     * This event bears no value.
     * Use `(deny)` (along with {@link showDenyButton}) when you want a modal with three buttons (confirm, deny and
     * cancel), and/or when you want to handle clear refusal in a separate way than simple dismissal.
     *
     * Example:
     *     <swal (deny)="handleDeny()"></swal>
     *
     *     public handleDeny(): void {
     *     }
     */
    deny = new EventEmitter();
    /**
     * Emits when the user clicks "Cancel", or dismisses the modal by any other allowed way.
     * The event value ($event) is a string that explains how the modal was dismissed. It is `undefined` when
     * the modal was programmatically closed (through {@link dismiss} for example).
     *
     * Example:
     *     <swal (dismiss)="handleDismiss($event)"></swal>
     *
     *     public handleDismiss(reason: DismissReason | undefined): void {
     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.
     *         // ... do something
     *     }
     */
    dismiss = new EventEmitter();
    /**
     * When the user does not provides a SwalComponent instance, we create it on-the-fly and assign the plain-object
     * options to it.
     * This fields keeps a reference to the dynamically-created <swal>, to destroy it along this directive instance.
     */
    swalRef;
    /**
     * An instance of the <swal> component that this directive controls.
     * Could be an instance passed by the user, otherwise it's the instance we've dynamically created.
     */
    swalInstance;
    /**
     * Holds the native SweetAlert2 options.
     * Empty when the user passed an existing SwalComponent instance.
     */
    swalOptions;
    constructor(viewContainerRef, resolver) {
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
    }
    /**
     * OnInit lifecycle handler.
     * Creates a SwalComponent instance if the user didn't provided one and binds on that component (confirm),
     * (deny) and (dismiss) outputs to reemit on the directive.
     */
    ngOnInit() {
        if (!this.swalInstance) {
            const factory = this.resolver.resolveComponentFactory(SwalComponent);
            this.swalRef = this.viewContainerRef.createComponent(factory);
            this.swalInstance = this.swalRef.instance;
        }
    }
    /**
     * OnDestroy lifecycle handler.
     * Destroys the dynamically-created SwalComponent.
     */
    ngOnDestroy() {
        if (this.swalRef) {
            this.swalRef.destroy();
        }
    }
    /**
     * Click handler.
     * The directive listens for onclick events on its host element.
     * When this happens, it shows the <swal> attached to this directive.
     */
    onClick(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        event.stopPropagation();
        if (!this.swalInstance)
            return;
        if (this.swalOptions) {
            this.swalInstance.swalOptions = this.swalOptions;
        }
        const swalClosed = new Subject();
        this.swalInstance.confirm.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.confirm.emit(v));
        this.swalInstance.deny.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.deny.emit(v));
        this.swalInstance.dismiss.asObservable().pipe(takeUntil(swalClosed)).subscribe(v => this.dismiss.emit(v));
        this.swalInstance.fire().then(() => swalClosed.next());
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.5", ngImport: i0, type: SwalDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.0.5", type: SwalDirective, selector: "[swal]", inputs: { swal: "swal" }, outputs: { confirm: "confirm", deny: "deny", dismiss: "dismiss" }, host: { listeners: { "click": "onClick($event)" } }, ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.5", ngImport: i0, type: SwalDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[swal]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }]; }, propDecorators: { swal: [{
                type: Input
            }], confirm: [{
                type: Output
            }], deny: [{
                type: Output
            }], dismiss: [{
                type: Output
            }], onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dhbC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtc3dlZXRhbGVydDIvc3JjL2xpYi9zd2FsLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ3FDLFNBQVMsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBcUIsTUFBTSxFQUVsSCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7O0FBRWpEOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUlILE1BQU0sT0FBTyxhQUFhO0lBeUZEO0lBQ0E7SUF6RnJCOzs7T0FHRztJQUNILElBQ1csSUFBSSxDQUFDLE9BQW1FO1FBQy9FLElBQUksT0FBTyxZQUFZLGFBQWEsRUFBRTtZQUNsQyxJQUFJLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQztTQUMvQjthQUFNLElBQUksY0FBYyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO1lBQ3RCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7U0FDcEY7YUFBTTtZQUNILElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDO1NBQzlCO1FBRUQsU0FBUyxjQUFjLENBQUMsS0FBVTtZQUM5QixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbEMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBRWEsT0FBTyxH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QUFNO2dCQXlEQSxPQUFPO3NCQURiLFlBQVk7dUJBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiwgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCBTd2FsLCB7IFN3ZWV0QWxlcnRBcnJheU9wdGlvbnMsIFN3ZWV0QWxlcnRPcHRpb25zIH0gZnJvbSAnc3dlZXRhbGVydDInO1xuaW1wb3J0IHsgU3dhbENvbXBvbmVudCB9IGZyb20gJy4vc3dhbC5jb21wb25lbnQnO1xuXG4vKipcbiAqIFtzd2FsXSBkaXJlY3RpdmUuIEl0IHRha2VzIGEgdmFsdWUgdGhhdCBkZWZpbmVzIHRoZSBTd2VldEFsZXJ0IGFuZCBjYW4gYmUgb2YgdGhyZWUgdHlwZXM6XG4gKlxuICogMSkgQSBzaW1wbGUgYXJyYXkgb2YgdHdvIG9yIHRocmVlIHN0cmluZ3MgZGVmaW5pbmcgW3RpdGxlLCB0ZXh0LCBpY29uXSAtIHRoZSBpY29uIGJlaW5nIG9wdGlvbmFsLCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cIlsnVGl0bGUnLCAnVGV4dCddXCI+Q2xpY2sgbWU8L2J1dHRvbj5cbiAqXG4gKiAyKSBBIG5hdGl2ZSBTd2VldEFsZXJ0MiBvcHRpb25zIG9iamVjdCwgZXg6XG4gKlxuICogICAgPGJ1dHRvbiBbc3dhbF09XCJ7IHRpdGxlOiAnVGl0bGUnLCB0ZXh0OiAnVGV4dCcgfVwiPkNsaWNrIG1lPC9idXR0b24+XG4gKlxuICogMykgQSByZWZlcmVuY2UgdG8gYW4gZXhpc3RpbmcgU3dhbENvbXBvbmVudCBpbnN0YW5jZSBmb3IgbW9yZSBhZHZhbmNlZCB1c2VzLCBleDpcbiAqXG4gKiAgICA8YnV0dG9uIFtzd2FsXT1cIm15U3dhbFwiPkNsaWNrIG1lPC9idXR0b24+XG4gKiAgICA8c3dhbCAjbXlTd2FsIHRpdGxlPVwiVGl0bGVcIiB0ZXh0PVwiVGV4dFwiPjwvc3dhbD5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbc3dhbF0nXG59KVxuZXhwb3J0IGNsYXNzIFN3YWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogU3dlZXRBbGVydDIgb3B0aW9ucyBvciBhIFN3YWxDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICogU2VlIHRoZSBjbGFzcyBkb2MgYmxvY2sgZm9yIG1vcmUgaW5mb3JtYXRpb25zLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBzd2FsKG9wdGlvbnM6IFN3YWxDb21wb25lbnQgfCBTd2VldEFsZXJ0T3B0aW9ucyB8IFN3ZWV0QWxlcnRBcnJheU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTd2FsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZSA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheU9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIFt0aGlzLnN3YWxPcHRpb25zLnRpdGxlLCB0aGlzLnN3YWxPcHRpb25zLnRleHQsIHRoaXMuc3dhbE9wdGlvbnMuaWNvbl0gPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zd2FsT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc0FycmF5T3B0aW9ucyh2YWx1ZTogYW55KTogdmFsdWUgaXMgU3dlZXRBbGVydEFycmF5T3B0aW9ucyB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiQ29uZmlybVwiLlxuICAgICAqIFRoZSBldmVudCB2YWx1ZSAoJGV2ZW50KSBjYW4gYmUgZWl0aGVyOlxuICAgICAqICAtIGJ5IGRlZmF1bHQsIGp1c3QgYHRydWVgLFxuICAgICAqICAtIHdoZW4gdXNpbmcge0BsaW5rIGlucHV0fSwgdGhlIGlucHV0IHZhbHVlLFxuICAgICAqICAtIHdoZW4gdXNpbmcge0BsaW5rIHByZUNvbmZpcm19LCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoY29uZmlybSk9XCJoYW5kbGVDb25maXJtKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZUNvbmZpcm0oZW1haWw6IHN0cmluZyk6IHZvaWQge1xuICAgICAqICAgICAgICAgLy8gLi4uIHNhdmUgdXNlciBlbWFpbFxuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGNvbmZpcm0gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIFwiRGVueVwiLlxuICAgICAqIFRoaXMgZXZlbnQgYmVhcnMgbm8gdmFsdWUuXG4gICAgICogVXNlIGAoZGVueSlgIChhbG9uZyB3aXRoIHtAbGluayBzaG93RGVueUJ1dHRvbn0pIHdoZW4geW91IHdhbnQgYSBtb2RhbCB3aXRoIHRocmVlIGJ1dHRvbnMgKGNvbmZpcm0sIGRlbnkgYW5kXG4gICAgICogY2FuY2VsKSwgYW5kL29yIHdoZW4geW91IHdhbnQgdG8gaGFuZGxlIGNsZWFyIHJlZnVzYWwgaW4gYSBzZXBhcmF0ZSB3YXkgdGhhbiBzaW1wbGUgZGlzbWlzc2FsLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiAgICAgPHN3YWwgKGRlbnkpPVwiaGFuZGxlRGVueSgpXCI+PC9zd2FsPlxuICAgICAqXG4gICAgICogICAgIHB1YmxpYyBoYW5kbGVEZW55KCk6IHZvaWQge1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRlbnkgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBcIkNhbmNlbFwiLCBvciBkaXNtaXNzZXMgdGhlIG1vZGFsIGJ5IGFueSBvdGhlciBhbGxvd2VkIHdheS5cbiAgICAgKiBUaGUgZXZlbnQgdmFsdWUgKCRldmVudCkgaXMgYSBzdHJpbmcgdGhhdCBleHBsYWlucyBob3cgdGhlIG1vZGFsIHdhcyBkaXNtaXNzZWQuIEl0IGlzIGB1bmRlZmluZWRgIHdoZW5cbiAgICAgKiB0aGUgbW9kYWwgd2FzIHByb2dyYW1tYXRpY2FsbHkgY2xvc2VkICh0aHJvdWdoIHtAbGluayBkaXNtaXNzfSBmb3IgZXhhbXBsZSkuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgICA8c3dhbCAoZGlzbWlzcyk9XCJoYW5kbGVEaXNtaXNzKCRldmVudClcIj48L3N3YWw+XG4gICAgICpcbiAgICAgKiAgICAgcHVibGljIGhhbmRsZURpc21pc3MocmVhc29uOiBEaXNtaXNzUmVhc29uIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgICogICAgICAgICAvLyByZWFzb24gY2FuIGJlICdjYW5jZWwnLCAnb3ZlcmxheScsICdjbG9zZScsICd0aW1lcicgb3IgdW5kZWZpbmVkLlxuICAgICAqICAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZ1xuICAgICAqICAgICB9XG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGRpc21pc3MgPSBuZXcgRXZlbnRFbWl0dGVyPFN3YWwuRGlzbWlzc1JlYXNvbiB8IHVuZGVmaW5lZD4oKTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHVzZXIgZG9lcyBub3QgcHJvdmlkZXMgYSBTd2FsQ29tcG9uZW50IGluc3RhbmNlLCB3ZSBjcmVhdGUgaXQgb24tdGhlLWZseSBhbmQgYXNzaWduIHRoZSBwbGFpbi1vYmplY3RcbiAgICAgKiBvcHRpb25zIHRvIGl0LlxuICAgICAqIFRoaXMgZmllbGRzIGtlZXBzIGEgcmVmZXJlbmNlIHRvIHRoZSBkeW5hbWljYWxseS1jcmVhdGVkIDxzd2FsPiwgdG8gZGVzdHJveSBpdCBhbG9uZyB0aGlzIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN3YWxSZWY/OiBDb21wb25lbnRSZWY8U3dhbENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgPHN3YWw+IGNvbXBvbmVudCB0aGF0IHRoaXMgZGlyZWN0aXZlIGNvbnRyb2xzLlxuICAgICAqIENvdWxkIGJlIGFuIGluc3RhbmNlIHBhc3NlZCBieSB0aGUgdXNlciwgb3RoZXJ3aXNlIGl0J3MgdGhlIGluc3RhbmNlIHdlJ3ZlIGR5bmFtaWNhbGx5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzd2FsSW5zdGFuY2U/OiBTd2FsQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIG5hdGl2ZSBTd2VldEFsZXJ0MiBvcHRpb25zLlxuICAgICAqIEVtcHR5IHdoZW4gdGhlIHVzZXIgcGFzc2VkIGFuIGV4aXN0aW5nIFN3YWxDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzd2FsT3B0aW9ucz86IFN3ZWV0QWxlcnRPcHRpb25zO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9uSW5pdCBsaWZlY3ljbGUgaGFuZGxlci5cbiAgICAgKiBDcmVhdGVzIGEgU3dhbENvbXBvbmVudCBpbnN0YW5jZSBpZiB0aGUgdXNlciBkaWRuJ3QgcHJvdmlkZWQgb25lIGFuZCBiaW5kcyBvbiB0aGF0IGNvbXBvbmVudCAoY29uZmlybSksXG4gICAgICogKGRlbnkpIGFuZCAoZGlzbWlzcykgb3V0cHV0cyB0byByZWVtaXQgb24gdGhlIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5zd2FsSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFN3YWxDb21wb25lbnQpO1xuXG4gICAgICAgICAgICB0aGlzLnN3YWxSZWYgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuICAgICAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2UgPSB0aGlzLnN3YWxSZWYuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbkRlc3Ryb3kgbGlmZWN5Y2xlIGhhbmRsZXIuXG4gICAgICogRGVzdHJveXMgdGhlIGR5bmFtaWNhbGx5LWNyZWF0ZWQgU3dhbENvbXBvbmVudC5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN3YWxSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhbFJlZi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGljayBoYW5kbGVyLlxuICAgICAqIFRoZSBkaXJlY3RpdmUgbGlzdGVucyBmb3Igb25jbGljayBldmVudHMgb24gaXRzIGhvc3QgZWxlbWVudC5cbiAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgaXQgc2hvd3MgdGhlIDxzd2FsPiBhdHRhY2hlZCB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmICghdGhpcy5zd2FsSW5zdGFuY2UpIHJldHVybjtcblxuICAgICAgICBpZiAodGhpcy5zd2FsT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2Uuc3dhbE9wdGlvbnMgPSB0aGlzLnN3YWxPcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3dhbENsb3NlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAgICAgdGhpcy5zd2FsSW5zdGFuY2UuY29uZmlybS5hc09ic2VydmFibGUoKS5waXBlKHRha2VVbnRpbChzd2FsQ2xvc2VkKSkuc3Vic2NyaWJlKHYgPT4gdGhpcy5jb25maXJtLmVtaXQodikpO1xuICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZS5kZW55LmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZVVudGlsKHN3YWxDbG9zZWQpKS5zdWJzY3JpYmUodiA9PiB0aGlzLmRlbnkuZW1pdCh2KSk7XG4gICAgICAgIHRoaXMuc3dhbEluc3RhbmNlLmRpc21pc3MuYXNPYnNlcnZhYmxlKCkucGlwZSh0YWtlVW50aWwoc3dhbENsb3NlZCkpLnN1YnNjcmliZSh2ID0+IHRoaXMuZGlzbWlzcy5lbWl0KHYpKTtcblxuICAgICAgICB0aGlzLnN3YWxJbnN0YW5jZS5maXJlKCkudGhlbigoKSA9PiBzd2FsQ2xvc2VkLm5leHQoKSk7XG4gICAgfVxufVxuIl19